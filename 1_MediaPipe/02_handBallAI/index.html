<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <title>MediaPipe Object Grab</title>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

    <style>
        body {
            margin: 0;
            background: #111;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            font-family: sans-serif;
        }

        canvas {
            border: 2px solid #444;
            margin-top: 10px;
        }
    </style>
</head>

<body>

    <h2>ì†ìœ¼ë¡œ ë¬¼ì²´ ì¡ê¸°</h2>

    <video class="input_video" style="display:none;"></video>
    <canvas class="output_canvas" width="640" height="480"></canvas>

    <script>
        const videoElement = document.querySelector('.input_video');
        const canvasElement = document.querySelector('.output_canvas');
        const canvasCtx = canvasElement.getContext('2d');

        // ğŸ¯ ë¬¼ì²´ ìƒì„±
        let object = {
            x: 320,
            y: 240,
            radius: 40,
            grabbed: false
        };

        const GRAB_THRESHOLD = 0.05;
        const RELEASE_THRESHOLD = 0.08;

        let isPinching = false;

        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(results => {

            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0,
                canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks) {

                const landmarks = results.multiHandLandmarks[0];

                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS);
                drawLandmarks(canvasCtx, landmarks);

                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];

                // ğŸ”¥ 1ï¸âƒ£ ì† ì¢Œí‘œë¥¼ í™”ë©´ ì¢Œí‘œë¡œ ë³€í™˜
                const handX = indexTip.x * canvasElement.width;
                const handY = indexTip.y * canvasElement.height;

                // ğŸ”¥ 2ï¸âƒ£ ì§‘ê¸° ê±°ë¦¬ ê³„ì‚°
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) +
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // ğŸ”¥ 3ï¸âƒ£ íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ì ìš©
                if (!isPinching && distance < GRAB_THRESHOLD) {
                    isPinching = true;
                } else if (isPinching && distance > RELEASE_THRESHOLD) {
                    isPinching = false;
                    object.grabbed = false;
                }

                // ğŸ”¥ 4ï¸âƒ£ ì†ê³¼ ë¬¼ì²´ ê±°ë¦¬ ê³„ì‚°
                const dx = object.x - handX;
                const dy = object.y - handY;
                const distToObject = Math.sqrt(dx * dx + dy * dy);

                // ğŸ”¥ 5ï¸âƒ£ ì§‘ê¸° + ê·¼ì ‘ ì‹œ ë¬¼ì²´ ì¡ê¸°
                if (isPinching && distToObject < object.radius + 20) {
                    object.grabbed = true;
                }

                // ğŸ”¥ 6ï¸âƒ£ ì¡ì•˜ìœ¼ë©´ ì† ë”°ë¼ì˜¤ê¸°
                if (object.grabbed) {
                    object.x = handX;
                    object.y = handY;
                }
            } else {
                object.grabbed = false;
                isPinching = false;
            }

            // ğŸ¨ ë¬¼ì²´ ê·¸ë¦¬ê¸°
            canvasCtx.beginPath();
            canvasCtx.arc(object.x, object.y, object.radius, 0, Math.PI * 2);
            canvasCtx.fillStyle = object.grabbed ? "red" : "cyan";
            canvasCtx.fill();
        });

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });

        camera.start();

    </script>
</body>

</html>